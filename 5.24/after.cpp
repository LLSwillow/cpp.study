//?? 一个（代码区 全局区）是由操作系统决定其生命周期 一个（栈区）是由编译器决定其生命周期 
// 会不会有由我们决定生命周期的？doge   哈哈哈堆区呀

/*栈区：  存放的数据是  局部变量
         不要返回（既然都提到返回了说明不是主函数中的局部变量 是函数中的）局部变量的地址 （刻舟求剑）
         函数调用返回后栈上的数据并没有被清空，而是程序失去了对栈所在内存的控制权

  堆区： 利用new关键字开辟一块区域（地址）所以类型应该是指针 类似于c语言中的int*p = (int *)malloc(sizeof(int))
         程序员 程序运行结束了 点❌ 堆区数据才被释放
        张三让李四对王五说，我爱你。李四说完就忘了。但是王五却记得，张三是爱我得
  
  */
#include<iostream>
using namespace std;
int* fun()
{
    int *p=new int(2);
    return p;
    //不可以返回局部变量的地址，但可以返回局部变量本身，恰好该局部变量是一个指针

    //堆区的数据不会改变，在栈上创建的指针 指向堆区的内存，栈上的指针会释放，但是堆区的数据不会释放。

    //函数里的局部变量里放的是个地址，函数把这个地址返回去，释放的只是 用来装这个地址的变量 的地址

    /*栈区的指针p保存地址，是在程序结束前的最后一步通过函数调用返回了。
    返回后，指针p才被释放。然后main函数中的变量接受到了返回值，这个值是堆区地址编号，不随栈区释放而释放。
    所以可以一直被解引用*/
}
int main()
{
    int *p=fun();
    cout <<*p<<endl;
    cout <<*p<<endl;
    cout <<*p<<endl;
    return 0;
}